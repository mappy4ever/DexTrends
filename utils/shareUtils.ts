import type { Pokemon } from "../types/pokemon";
import logger from './logger';

/**
 * Share methods for Pokemon data
 */
export type ShareMethod = 'link' | 'image' | 'stats' | 'qr';

/**
 * Notification instance that will be set from components using this utility
 * Components should call setNotificationInstance with their notification context
 */
let notificationInstance: unknown = null;

/**
 * Set the notification instance for this utility to use
 * Should be called by components that use share functionality
 */
export const setNotificationInstance = (instance: unknown) => {
  notificationInstance = instance;
};

/**
 * Show a toast notification using the app's notification system
 */
const showToast = (message: string) => {
  if (notificationInstance && notificationInstance.notify) {
    notificationInstance.notify.success(message);
  } else {
    // Fallback to logger if notification system not available
    logger.debug('Share notification:', { message });
    
    // Temporary visual feedback
    const toast = document.createElement('div');
    toast.className = 'fixed bottom-4 left-1/2 transform -translate-x-1/2 bg-gray-800 text-white px-6 py-3 rounded-lg shadow-lg z-50 animate-fade-in';
    toast.textContent = message;
    document.body.appendChild(toast);
    
    setTimeout(() => {
      toast.remove();
    }, 3000);
  }
};

/**
 * Generate stats text for copying
 */
function generateStatsText(pokemon: Pokemon): string {
  const stats = pokemon.stats?.map(s => `${s.stat.name}: ${s.base_stat}`).join('\n') || '';
  const types = pokemon.types?.map(t => t.type.name).join(', ') || '';
  
  return `${pokemon.name.toUpperCase()} #${pokemon.id}
Types: ${types}

Base Stats:
${stats}
Total: ${pokemon.stats?.reduce((sum, s) => sum + s.base_stat, 0) || 0}

Height: ${((pokemon.height || 0) / 10).toFixed(1)}m
Weight: ${((pokemon.weight || 0) / 10).toFixed(1)}kg`;
}

/**
 * Generate a Pokemon card as canvas image
 */
async function generatePokemonCard(pokemon: Pokemon): Promise<HTMLCanvasElement> {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  
  if (!ctx) throw new Error('Could not create canvas context');
  
  // Set canvas dimensions
  canvas.width = 400;
  canvas.height = 600;
  
  // Background gradient
  const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
  gradient.addColorStop(0, '#f3f4f6');
  gradient.addColorStop(1, '#e5e7eb');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Draw Pokemon image
  const img = new Image();
  img.crossOrigin = 'anonymous';
  
  return new Promise((resolve, reject) => {
    img.onload = () => {
      // Draw white circle background
      ctx.beginPath();
      ctx.arc(canvas.width / 2, 150, 100, 0, Math.PI * 2);
      ctx.fillStyle = 'white';
      ctx.fill();
      ctx.closePath();
      
      // Draw Pokemon sprite
      ctx.drawImage(img, canvas.width / 2 - 80, 70, 160, 160);
      
      // Draw name
      ctx.fillStyle = '#1f2937';
      ctx.font = 'bold 32px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(pokemon.name.toUpperCase(), canvas.width / 2, 280);
      
      // Draw ID
      ctx.font = '20px Arial';
      ctx.fillStyle = '#6b7280';
      ctx.fillText(`#${String(pokemon.id).padStart(4, '0')}`, canvas.width / 2, 310);
      
      // Draw types
      const types = pokemon.types?.map(t => t.type.name.toUpperCase()).join(' / ') || '';
      ctx.font = '18px Arial';
      ctx.fillText(types, canvas.width / 2, 340);
      
      // Draw stats
      ctx.font = '16px Arial';
      ctx.textAlign = 'left';
      ctx.fillStyle = '#374151';
      
      let y = 380;
      pokemon.stats?.forEach(stat => {
        const statName = stat.stat.name.replace('-', ' ').toUpperCase();
        ctx.fillText(`${statName}: ${stat.base_stat}`, 50, y);
        
        // Draw stat bar
        ctx.fillStyle = '#e5e7eb';
        ctx.fillRect(200, y - 12, 150, 10);
        ctx.fillStyle = '#3b82f6';
        ctx.fillRect(200, y - 12, (stat.base_stat / 255) * 150, 10);
        
        ctx.fillStyle = '#374151';
        y += 30;
      });
      
      // Draw total
      const total = pokemon.stats?.reduce((sum, s) => sum + s.base_stat, 0) || 0;
      ctx.font = 'bold 18px Arial';
      ctx.fillText(`TOTAL: ${total}`, 50, y + 10);
      
      // Add watermark
      ctx.font = '12px Arial';
      ctx.fillStyle = '#9ca3af';
      ctx.textAlign = 'center';
      ctx.fillText('Generated by DexTrends', canvas.width / 2, canvas.height - 20);
      
      resolve(canvas);
    };
    
    img.onerror = () => {
      reject(new Error('Failed to load Pokemon image'));
    };
    
    // Use sprite URL
    const spriteUrl = pokemon.sprites?.other?.['official-artwork']?.front_default || 
                     pokemon.sprites?.front_default || '';
    img.src = spriteUrl;
  });
}

/**
 * Convert canvas to blob
 */
async function canvasToBlob(canvas: HTMLCanvasElement): Promise<Blob> {
  return new Promise((resolve, reject) => {
    canvas.toBlob((blob) => {
      if (blob) {
        resolve(blob);
      } else {
        reject(new Error('Failed to convert canvas to blob'));
      }
    }, 'image/png');
  });
}

/**
 * Share an image blob
 */
async function shareImage(blob: Blob, name: string) {
  // If Web Share API supports files
  if (navigator.share && navigator.canShare && navigator.canShare({ files: [new File([blob], `${name}.png`)] })) {
    const file = new File([blob], `${name}.png`, { type: 'image/png' });
    await navigator.share({
      files: [file],
      title: `${name} Pokemon Card`,
    });
  } else {
    // Fallback: download the image
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${name}-pokemon-card.png`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    showToast('Pokemon card downloaded!');
  }
}

/**
 * Generate QR code for URL
 */
async function generateQRCode(url: string): Promise<string> {
  // Using QR Server API (free, no key required)
  const qrApiUrl = `https://api.qrserver.com/v1/create-qr-code/?size=300x300&data=${encodeURIComponent(url)}`;
  return qrApiUrl;
}

/**
 * Main share function
 */
export async function sharePokemon(pokemon: Pokemon, method: ShareMethod) {
  try {
    switch (method) {
      case 'link':
        if (navigator.share) {
          await navigator.share({
            title: `${pokemon.name} - #${pokemon.id}`,
            text: `Check out ${pokemon.name} on DexTrends!`,
            url: window.location.href
          });
        } else {
          await navigator.clipboard.writeText(window.location.href);
          showToast('Link copied to clipboard!');
        }
        break;
        
      case 'image':
        const canvas = await generatePokemonCard(pokemon);
        const blob = await canvasToBlob(canvas);
        await shareImage(blob, pokemon.name);
        break;
        
      case 'stats':
        const statsText = generateStatsText(pokemon);
        await navigator.clipboard.writeText(statsText);
        showToast('Stats copied to clipboard!');
        break;
        
      case 'qr':
        const qrDataUrl = await generateQRCode(window.location.href);
        // Open QR code in new tab for now
        window.open(qrDataUrl, '_blank');
        showToast('QR code opened in new tab!');
        break;
    }
  } catch (error) {
    logger.error('Share error:', { error });
    showToast('Failed to share. Please try again.');
  }
}